---
title: "Assignment 1"
author: "Stefano Graziosi, Gabriele Molè, Laura Lo Schiavo, Giovanni Carron"
format: html
editor: visual
---

```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
#| label: "Load Libraries"

# Conflict resolution
library(conflicted)
conflicts_prefer(dplyr::filter)

# Core Tidyverse for data manipulation and visualization
library(tidyverse)
library(lubridate)

# Time Series packages
library(dlm)
library(TSstudio)
library(feasts)
library(tseries)
library(quantmod) # Includes zoo and xts

# Datasets
library(fpp3)

# Plotting and theming
library(ggthemes)
library(viridis)
library(gridExtra)

# Other utilities
library(tinytex)
```

# Description of the problem

## Data

```{r load-data}
#| label: "Load Data"
# Load the dataset from the data subfolder
data <- read.csv("data/gistemp.txt", header = TRUE)

# Extract monthly data and convert to a time series object
monthly_data <- data[, 2:13]
ts_data <- ts(as.vector(t(monthly_data)), start = c(1880, 1), frequency = 12)
```

# 1. Task 1

## 1.1 Trend Analysis

> What long-term trends are visible in the temperature data?

### 1.1.1 Using the `decompose` function

We first create two objects that will take the values of the decomposed time series. We try both additive and multiplicative decomposition for the sake of completeness.

```{r decompose-data}
decompose_a_data <- decompose(ts_data, type = "additive")
decompose_m_data <- decompose(ts_data, type = "multiplicative")
```

We now plot both objects.

```{r plot-decompose-additive}
plot(decompose_a_data)
```

```{r plot-decompose-multiplicative}
plot(decompose_m_data)
```

An alternative is to simply use the command `ts_decompose` from the package `TSstudio`

```{r ts-decompose-both}
ts_decompose(ts_data, type = "both")
```

### 1.1.2 Using the `stl` function

```{r stl-decomposition}
stl_data <- stl(ts_data, s.window = "periodic")
plot(stl_data)
```

> What long-term trends are visible in the temperature data?

To visualize the trend more clearly, we'll create a more polished plot. First, we generate a sequence of dates corresponding to our time series data.

```{r create-dates}
dates <- seq.Date(
  from = as.Date("1880-01-01"),
  by = "month",
  length.out = length(ts_data)
)
```

Now we create a dataframe which contains the date and the actual values taken by the time series.

```{r create-ts-dataframe}
ts_df <- data.frame(date = dates, value = as.numeric(ts_data))
```

We use the object we just created to plot a nice graph using ggplot.

```{r plot-trend}
graph_1 <- ggplot(ts_df, aes(x = date, y = value)) +
  geom_line(color = "steelblue", linewidth = 0.25) +
  geom_smooth(
    method = "loess",
    color = "firebrick",
    fill = "firebrick",
    se = TRUE,
    show.legend = TRUE,
    linetype = "dashed",
    linewidth = 0.25
  ) +
  geom_hline(yintercept = 0, color = "orange", linetype = "dashed", linewidth = 0.5) +
  labs(
    title = "Global Temperature Anomaly Trend",
    subtitle = "GISTEMP Data (1880 onward)",
    x = "Date",
    y = "Temperature Anomaly (°C)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
    plot.subtitle = element_text(size = 14, hjust = 0.5),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "gray20")
  )

print(graph_1)
ggsave("output_ps1/graph_1.pdf", plot = graph_1, device = "pdf", width = 10, height = 6, units = "in")

```

> Are there periods of acceleration or deceleration in warming?

As we can see from the graph above, considering that we are already using the $\Delta$ in temperatures, any year where the $\Delta$ is negative is a year where there is a deceleration in warming; hence, from 1880 to approximately 1938, we observe that the Earth's surface temperature is actually getting cooler.

We then observe a rapid increase in conjunction with the start of the Second World War, a brief decline afterwards and, ultimately, a rapid increase starting from the post-war recovery period. Starting from 1950, we observe a rapid acceleration in the rate of change of temperature.

## 1.2 Seasonality

> Can you interpret the seasonal pattern?

### 1.2.1 Comparison between different decompositions

```{r extract-seasonal-components}
seasonal_da <- decompose_a_data$seasonal
seasonal_dm <- decompose_m_data$seasonal
seasonal_stl <- stl_data$time.series[, "seasonal"]
```

As we did in the previous step, if we want to plot something, we first need to create a new dataframe (`_df`) object in order to plot everything nicely.

```{r create-seasonal-dfs}
seasonal_da_df <- data.frame(date = dates, value = as.numeric(seasonal_da))
seasonal_dm_df <- data.frame(date = dates, value = as.numeric(seasonal_dm))
seasonal_stl_df <- data.frame(date = dates, value = as.numeric(seasonal_stl))
```

```{r plot-seasonal-components, fig.height=8}
graph_2a <- ggplot(seasonal_da_df, aes(x = date, y = value)) +
  geom_line(color = "steelblue", linewidth = 0.25) +
  labs(title = "Additive Decomposition") +
  theme_minimal()

graph_2b <- ggplot(seasonal_dm_df, aes(x = date, y = value)) +
  geom_line(color = "steelblue", linewidth = 0.25) +
  labs(title = "Multiplicative Decomposition") +
  theme_minimal()

graph_2c <- ggplot(seasonal_stl_df, aes(x = date, y = value)) +
  geom_line(color = "steelblue", linewidth = 0.25) +
  labs(title = "STL Decomposition") +
  theme_minimal()

grid.arrange(graph_2a, graph_2b, graph_2c, nrow = 3)
```

It appears that we're getting the same seasonality for each year. It may be more informative to plot the data for a single year, for instance, the last year available.

We first have to create the opportune dataframe:

```{r seasonal-last-year}
seasonal_da_ly <- window(seasonal_da, start = time(seasonal_da)[length(seasonal_da) - frequency(seasonal_da) + 1])
seasonal_dm_ly <- window(seasonal_dm, start = time(seasonal_dm)[length(seasonal_dm) - frequency(seasonal_dm) + 1])
seasonal_stl_ly <- window(seasonal_stl, start = time(seasonal_stl)[length(seasonal_stl) - frequency(seasonal_stl) + 1])
```

Now we just merge these 3 values into a dataframe to plot it:

```{r combine-seasonal-ly}
seasonal_comparison_df <- data.frame(
  time = time(seasonal_da_ly),
  additive = as.numeric(seasonal_da_ly),
  # Multiplicative is excluded as the seasonality difference is too large to be plausible
  # multiplicative = as.numeric(seasonal_dm_ly),
  stl = as.numeric(seasonal_stl_ly)
)

seasonal_comparison_df_long <- pivot_longer(seasonal_comparison_df,
  cols = c("additive", "stl"),
  names_to = "methodology",
  values_to = "value"
)
```

```{r plot-seasonal-comparison}
# convert the last-year seasonal ts into a month factor and plot
seasonal_comparison_df <- data.frame(
  month = factor(month.abb[cycle(seasonal_da_ly)], levels = month.abb), # "Jan","Feb",...
  additive = as.numeric(seasonal_da_ly),
  stl = as.numeric(seasonal_stl_ly)
)

seasonal_comparison_df_long <- pivot_longer(
  seasonal_comparison_df,
  cols = c("additive", "stl"),
  names_to = "methodology",
  values_to = "value"
)

graph_3 <- ggplot(seasonal_comparison_df_long, aes(x = month, y = value, color = methodology, group = methodology)) +
  geom_line(linewidth = 0.8) +
  geom_point(size = 1.5) +
  geom_hline(yintercept = 0, color = "orange", linetype = "dashed", linewidth = 0.5) +
  labs(title = "Seasonality Over One Year", x = "Month", y = "Δ Temperature") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "gray20")
  )

print(graph_3)
ggsave("output_ps1/graph_3_months.pdf", plot = graph_3, width = 10, height = 6)
```

 We can safely state that the methodology that we apply does not effect drastic differences on the calculation of the seasonal component.

### 1.2.2 Comparison between different time frames

```{r seasonal-timeframes, message=FALSE}
start_years <- seq(min(data$Year), max(data$Year) - 29, by = 10)
seasonal_indices <- data.frame()

for (start in start_years) {
  # Subset the data for the 30-year period
  subset_data <- subset(data, Year >= start & Year < start + 30)

  # Reshape to long format for the subset
  subset_long <- subset_data %>%
    select(Year, Jan:Dec) %>%
    pivot_longer(cols = Jan:Dec, names_to = "Month", values_to = "Anomaly") %>%
    mutate(Month = match(Month, month.abb))

  # Create a ts object for the subset
  ts_subset <- ts(subset_long$Anomaly, start = c(start, 1), frequency = 12)

  # Decompose using STL
  decomp_subset <- stl(ts_subset, s.window = "periodic")

  # Extract the seasonal component and average by month
  seasonal_comp <- decomp_subset$time.series[, "seasonal"]
  temp_df <- data.frame(
    Date = as.Date(zoo::as.yearmon(time(ts_subset))),
    Month = cycle(ts_subset),
    Seasonal = seasonal_comp
  )
  seasonal_mean <- aggregate(Seasonal ~ Month, data = temp_df, FUN = mean)
  seasonal_mean$Period <- paste(start, start + 29, sep = "-")

  seasonal_indices <- rbind(seasonal_indices, seasonal_mean)
}

seasonal_indices$Month <- factor(seasonal_indices$Month,
  levels = 1:12,
  labels = month.name
)
```

#### 1.2.2.a

```{r plot-seasonal-evolution}
graph_4 <- ggplot(seasonal_indices, aes(x = Month, y = Seasonal, group = Period, color = Period)) +
  geom_hline(yintercept = 0, color = "orange", linetype = "dashed", linewidth = 0.5) +
  geom_line(linewidth = 0.5) +
  geom_point(size = 0.75) +
  scale_color_viridis_d(option = "H") +
  labs(
    title = "Evolution of Seasonal Component",
    y = "Average Seasonal Component",
    x = "Month"
  ) +
  guides(x = guide_axis(angle = 45)) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "gray20")
  )

print(graph_4)
ggsave("output_ps1/graph_4.pdf", plot = graph_4, device = "pdf", width = 8, height = 6, units = "in")
```

#### 1.2.2.b

From 1880-1909 to 1940-1969

```{r plot-seasonal-before-1970}
seasonal_indices_before <- seasonal_indices %>% filter(as.numeric(substr(Period, 1, 4)) < 1950)

graph_5 <- ggplot(seasonal_indices_before, aes(x = Month, y = Seasonal, group = Period, color = Period)) +
  geom_hline(yintercept = 0, color = "orange", linetype = "dashed", linewidth = 0.5) +
  geom_line(linewidth = 0.5) +
  geom_point(size = 0.75) +
  scale_color_viridis_d(option = "C") +
  labs(
    title = "Evolution of Seasonal Component (1880-1969)",
    y = "Average Seasonal Component",
    x = "Month"
  ) +
  guides(x = guide_axis(angle = 45)) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "gray20")
  )

print(graph_5)
ggsave("output_ps1/graph_5.pdf", plot = graph_5, device = "pdf", width = 8, height = 6, units = "in")
```

From 1950-1979 to 1990-2019

```{r plot-seasonal-after-1950}
seasonal_indices_after <- seasonal_indices %>% filter(as.numeric(substr(Period, 1, 4)) >= 1950)

graph_6 <- ggplot(seasonal_indices_after, aes(x = Month, y = Seasonal, group = Period, color = Period)) +
  geom_hline(yintercept = 0, color = "orange", linetype = "dashed", linewidth = 0.5) +
  geom_line(linewidth = 0.5) +
  geom_point(size = 0.75) +
  scale_color_viridis_d(option = "D") +
  labs(
    title = "Evolution of Seasonal Component (1950-2019)",
    y = "Average Seasonal Component",
    x = "Month"
  ) +
  guides(x = guide_axis(angle = 45)) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "gray20")
  )

print(graph_6)
ggsave("output_ps1/graph_6.pdf", plot = graph_6, device = "pdf", width = 8, height = 6, units = "in")
```

## 1.3 Noise and Uncertainty

> Briefly comment on the variation that is unexplained by the decomposition. Are there anomalies in the residuals?

We can plot the residuals from the three decomposition methods to investigate.

```{r extract-residuals}
residuals_da <- decompose_a_data$random
residuals_dm <- decompose_m_data$random
residuals_stl <- stl_data$time.series[, "remainder"]
```

As before, we create dataframes for plotting with `ggplot2`.

```{r create-residuals-dfs}
residuals_da_df <- data.frame(date = dates, value = as.numeric(residuals_da))
residuals_dm_df <- data.frame(date = dates, value = as.numeric(residuals_dm))
residuals_stl_df <- data.frame(date = dates, value = as.numeric(residuals_stl))
```

We can inspect the residuals graphically. A custom theme is created for consistency.

```{r custom-theme-residuals}
custom_theme <- theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
    plot.subtitle = element_text(size = 14, hjust = 0.5),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "gray20")
  )
```

```{r plot-residuals, fig.height=12}
custom_theme <- theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
    plot.subtitle = element_text(size = 14, hjust = 0.5),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "gray20")
  )

res_plot_da <- ggplot(residuals_da_df, aes(x = date, y = value)) +
  geom_point(size = 0.5, alpha = 0.5) +
  custom_theme +
  labs(title = "Additive Residuals", x = "Date", y = "Value")

res_plot_dm <- ggplot(residuals_dm_df, aes(x = date, y = value)) +
  geom_point(size = 0.5, alpha = 0.5) +
  custom_theme +
  labs(title = "Multiplicative Residuals", x = "Date", y = "Value")

res_plot_stl <- ggplot(residuals_stl_df, aes(x = date, y = value)) +
  geom_point(size = 0.5, alpha = 0.5) +
  custom_theme +
  labs(title = "STL Residuals", x = "Date", y = "Value")

grid.arrange(res_plot_da, res_plot_dm, res_plot_stl, nrow = 3)
```

To approach the task in a more rigorous way, we can also implement a series of statistical tests.

### 1.3.1 Ljung-Box Test

The Ljung-Box test checks for autocorrelation in the residuals. The null hypothesis is that the residuals are independently distributed.

```{r ljung-box-test}
Box.test(na.omit(residuals_da), lag = 12, type = "Ljung-Box")
Box.test(na.omit(residuals_dm), lag = 12, type = "Ljung-Box")
Box.test(na.omit(residuals_stl), lag = 12, type = "Ljung-Box")
```

### 1.3.2 Shapiro-Wilk Test

The Shapiro-Wilk test checks for normality of the residuals. The null hypothesis is that the residuals are normally distributed.

```{r shapiro-test}
shapiro.test(na.omit(residuals_da))
shapiro.test(na.omit(residuals_dm))
shapiro.test(na.omit(residuals_stl))
```

### 1.3.3 ACF Plots

ACF plots help visualize any remaining autocorrelation in the residuals.

```{r acf-plots}
par(mfrow = c(1, 3))
acf(na.omit(residuals_da), main = "ACF of Additive Residuals")
acf(na.omit(residuals_dm), main = "ACF of Multiplicative Residuals")
acf(na.omit(residuals_stl), main = "ACF of STL Residuals")
par(mfrow = c(1, 1))
```

---

# 2. Task 2

> You will now focus on the trend extracted from data in section 2, specifically on the window ranging from the beginning up to December 1930. Imagine the data arrive sequentially. Fit an exponential smoothing model.

## Setting everything up

Taking the values for the subset 1880-1930 and plotting.

```{r subset-data-1930}
ts_data_sub <- window(ts_data, end = c(1930, 12))
plot(ts_data_sub)
```

As we don't notice significant trends we now opt for a simple exponential smoothing.

## 2.1 Values of the α parameter

> Comment on the value of the α parameter used in the R function HoltWinters. How is it determined? Try another small set of values, showing how the resulting fitted values change.

The alpha parameter is typically determined by minimizing the one-step-ahead prediction error.

```{r holt-winters-alpha}
# Ensure no NAs are in the time series
ts_data_sub_clean <- ts_data_sub[is.finite(ts_data_sub)]
HWdata <- HoltWinters(ts_data_sub_clean, beta = FALSE, gamma = FALSE)
plot(HWdata)
alpha <- HWdata$alpha
print(paste("Optimal alpha:", alpha))
```

Errors of prediction within sample 1880-1930:

```{r prediction-errors}
yhat <- fitted(HWdata)[, 1]
ts_data_sub_removed <- window(ts_data_sub_clean, start = c(1880, 2))

# MAE
mae <- mean(abs(ts_data_sub_removed - yhat))
# MAPE
mape <- mean(abs(ts_data_sub_removed - yhat) / ts_data_sub_removed)
# MSE
mse <- mean((ts_data_sub_removed - yhat)^2)

print(paste("MAE:", mae))
print(paste("MAPE:", mape))
print(paste("MSE:", mse))
```

## 2.2 One-step-ahead predictions

> In particular, plot the one-step-ahead predictions for this time interval and compare them to the observed values.

```{r hw-different-alphas, fig.height=10}
par(mfrow = c(3, 1), cex = .6)
# alpha 0.1
HWdata_01 <- HoltWinters(ts_data_sub_clean, alpha = 0.1, beta = FALSE, gamma = FALSE)
plot(HWdata_01, main = "Alpha = 0.1")

# Optimal alpha from HW
plot(HWdata, main = paste("Optimal Alpha =", round(alpha, 3)))

# alpha 0.9
HWdata_09 <- HoltWinters(ts_data_sub_clean, alpha = 0.9, beta = FALSE, gamma = FALSE)
plot(HWdata_09, main = "Alpha = 0.9")
par(mfrow = c(1, 1))
```

```{r plot-smoothing-comparison}
# Extract fitted values
smoothed_data <- data.frame(
  time = time(ts_data_sub_removed),
  original = as.numeric(ts_data_sub_removed),
  Alpha_HW = HWdata$fitted[, 1],
  Alpha_0.1 = HWdata_01$fitted[, 1],
  Alpha_0.9 = HWdata_09$fitted[, 1]
)

# Convert to long format for ggplot
smoothed_long <- smoothed_data %>%
  pivot_longer(cols = -time, names_to = "Series", values_to = "Value")

# Plot using ggplot
ggplot(smoothed_long, aes(x = time, y = Value, color = Series)) +
  geom_line(linewidth = 0.5) +
  scale_color_manual(values = c("purple", "steelblue", "forestgreen", "orange")) +
  labs(
    title = "Exponential Smoothing with Different Alpha Values",
    x = "Time", y = "Value", color = "Series"
  ) +
  theme_minimal()
```

## 2.3 Analytic expression of forecast function

> Specify the analytic expression of the forecast function of the exponential smoothing algorithm for different time steps.

Coefficients:

```{r hw-coefficients}
HWdata$coefficients
```

The forecast function for simple exponential smoothing is a constant value for all future horizons, equal to the level component at the end of the series.
$$
\hat{y}_{T+h|T} = \ell_T
$$
For this model, the forecast is:
$$
\hat{y}_{t} \approx -0.02126
$$

## 2.4 Forecasts from 1930

> Now assume that you are a statistician from December 1930 and you want to predict (through exponential smoothing) the temperature difference for the following 95 years (i.e. up to 2024). Plot the forecasts and the observed values.

```{r forecast-1930}
# Number of periods to forecast
n_forecast <- length(ts_data) - length(ts_data_sub_clean)

# Generate predictions
HW_pred <- predict(HWdata, n_forecast, prediction.interval = TRUE, level = 0.95)

# Observed data for the forecast period
observed_data <- window(ts_data, start = c(1931, 1))

# Plot observed vs. forecast
ts.plot(observed_data, HW_pred[, 1],
  gpars = list(
    main = "Forecast vs. Observed Data (1931-2024)",
    col = c("black", "red"),
    xlab = "Year",
    ylab = "Temperature Anomaly"
  )
)
legend("topleft", legend = c("Observed", "Forecast"), col = c("black", "red"), lty = 1)
```

Plotting forecast errors:

```{r plot-forecast-errors, fig.height=8}
forecast_error <- HW_pred[, 1] - observed_data

par(mfrow = c(2, 2), cex = .6)
plot.ts(forecast_error, main = "Raw Error")
plot.ts(abs(forecast_error), main = "Absolute Error")
plot.ts(abs(forecast_error / observed_data), main = "Absolute Percentage Error")
plot.ts(forecast_error^2, main = "Squared Error")
par(mfrow = c(1, 1))

```